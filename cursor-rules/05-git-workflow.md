# Git Workflow - Автоматизация версионного контроля

## 1. Инициализация Git при начале работы

### Проверка и инициализация репозитория
```bash
# Проверить есть ли Git репозиторий
if [ ! -d ".git" ]; then
    git init
    echo "✅ Git репозиторий инициализирован"
else
    echo "✅ Git репозиторий уже существует"
fi
```

### Базовая настройка .gitignore
```gitignore
# 1С файлы
*.dt
*.1cd
*.cf
*.epf
*.erf
*.ert
*.md5
*.tmp
*.log

# Cursor временные файлы
.cursor/
*.cursor-*

# Системные файлы
.DS_Store
Thumbs.db
*.swp
*.swo
*~
```

## 2. Полный процесс работы с изменениями

### Этап 1: Подготовка к изменениям
```bash
# 1. Переключиться на главную ветку
git checkout main

# 2. Обновить ветку
git pull origin main

# 3. Создать ветку для задачи
TASK_NAME="feature/$(date +%Y%m%d-%H%M%S)-task-description"
git checkout -b "$TASK_NAME"
```

### Этап 2: Выполнение изменений
```bash
# 1. Сделать изменения в коде
# [здесь происходят изменения через Cursor/код]

# 2. Добавить изменения в индекс
git add .

# 3. Зафиксировать промежуточное состояние
git commit -m "WIP: описание изменений"
```

### Этап 3: Проверка изменений
```bash
# 1. Проверить синтаксис/компиляцию
# [автоматическая проверка через linter/компилятор]

# 2. Если есть ошибки - исправить и повторить
if [ $? -ne 0 ]; then
    echo "❌ Обнаружены ошибки - исправляем"
    # [исправления]
    git add .
    git commit -m "fix: исправление ошибок"
fi
```

### Этап 4: Финализация (при успешной проверке)
```bash
# 1. Окончательный коммит
git add .
git commit -m "feat: финальная версия изменений - описание"

# 2. Переключиться на главную ветку
git checkout main

# 3. Слияние ветки
git merge "$TASK_NAME" --no-ff

# 4. Удалить рабочую ветку
git branch -d "$TASK_NAME"

# 5. Отправить изменения в удаленный репозиторий (если есть)
git push origin main
```

## 3. Автоматизированные команды для Cursor

### Команда "Начать задачу"
```bash
#!/bin/bash
# start-task.sh
TASK_DESC="${1:-general-changes}"
BRANCH_NAME="feature/$(date +%Y%m%d-%H%M%S)-$TASK_DESC"

git checkout main
git pull origin main 2>/dev/null || true
git checkout -b "$BRANCH_NAME"

echo "✅ Создана ветка: $BRANCH_NAME"
echo "✅ Готов к внесению изменений"
```

### Команда "Сохранить прогресс"
```bash
#!/bin/bash
# save-progress.sh
MESSAGE="${1:-WIP: промежуточные изменения}"

git add .
git commit -m "$MESSAGE"

echo "✅ Прогресс сохранен: $MESSAGE"
```

### Команда "Завершить задачу"
```bash
#!/bin/bash
# finish-task.sh
MESSAGE="${1:-feat: завершение задачи}"
CURRENT_BRANCH=$(git branch --show-current)

# Проверка что не на main
if [ "$CURRENT_BRANCH" = "main" ]; then
    echo "❌ Уже на main ветке"
    exit 1
fi

# Финальный коммит
git add .
git commit -m "$MESSAGE"

# Переключение и слияние
git checkout main
git merge "$CURRENT_BRANCH" --no-ff

# Удаление ветки
git branch -d "$CURRENT_BRANCH"

# Отправка в удаленный репозиторий
git push origin main 2>/dev/null || echo "⚠️ Удаленный репозиторий недоступен"

echo "✅ Задача завершена и слита с main"
```

## 4. Интеграция с процессом разработки

### Обязательные моменты для Git операций:
1. **Перед началом любых изменений** - создать ветку
2. **После каждого логического блока изменений** - коммит
3. **Перед тестированием** - сохранить состояние
4. **При успешном завершении** - слить с main
5. **При ошибках** - либо исправить в той же ветке, либо откатиться

### Правила именования веток:
- `feature/YYYYMMDD-HHMM-описание` - новые функции
- `fix/YYYYMMDD-HHMM-описание` - исправления
- `docs/YYYYMMDD-HHMM-описание` - документация
- `refactor/YYYYMMDD-HHMM-описание` - рефакторинг

### Правила сообщений коммитов:
- `feat:` - новая функциональность
- `fix:` - исправление ошибки
- `docs:` - изменения в документации
- `style:` - форматирование, отсутствующие точки с запятой и т.д.
- `refactor:` - рефакторинг кода
- `test:` - добавление тестов
- `chore:` - обновление задач сборки и т.д.

## 5. Обработка ошибок

### При возникновении ошибок компиляции/линтера:
```bash
# 1. Сохранить текущее состояние
git add .
git commit -m "WIP: состояние с ошибками для анализа"

# 2. Исправить ошибки
# [процесс исправления]

# 3. Зафиксировать исправления
git add .
git commit -m "fix: исправление ошибок компиляции/линтера"
```

### При критических ошибках (откат):
```bash
# Откат к последнему рабочему состоянию
git reset --hard HEAD~1

# Или откат к состоянию main
git checkout main
git branch -D "$PROBLEMATIC_BRANCH"
```

## 6. Мониторинг и логирование

### Ведение истории изменений:
- Каждый коммит должен содержать понятное описание
- Использовать теги для важных версий: `git tag -a v1.0.0 -m "Версия 1.0.0"`
- Ведение CHANGELOG.md с описанием изменений

### Автоматические проверки:
- Проверка синтаксиса перед коммитом
- Проверка соответствия правилам именования
- Автоматическое форматирование кода

## 7. Интеграция с Cursor Rules

Данный Git workflow должен автоматически применяться при:
- Создании новых файлов
- Изменении существующего кода
- Обновлении документации
- Исправлении ошибок

**Обязательное правило:** НИ ОДНО изменение не должно происходить без Git контроля! 