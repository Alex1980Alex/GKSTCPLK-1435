#Если Сервер Или ВнешнееСоединение Или ТолстыйКлиентОбычноеПриложение Тогда

Перем Клиент;

#Область ПрограммныйИнтерфейс

// Установить соединение
//
// Параметры:
//  АдресСервера	 - Строка	 - IP или сетевое имя сервера RMQ
//  ИмяПользователя	 - Строка	 - логин
//  Пароль			 - Строка	 - пароль
//  ПортСервера		 - Число	 - порт сервера RMQ
//  ВиртуальныйХост	 - Строка	 - имя хоста внутри RMQ
//  ЧастотаПульса	 - Число	 - частота пакетов heartbeat. 0 - не высылать.
//
Процедура УстановитьСоединение(
	Знач АдресСервера,
	Знач ИмяПользователя,
	Знач Пароль,
	Знач ПортСервера = 5672,
	Знач ВиртуальныйХост = "/",
	Знач ЧастотаПульса = 15) Экспорт

	Попытка
		Клиент.Connect(АдресСервера, ПортСервера, ИмяПользователя, Пароль, ВиртуальныйХост, ЧастотаПульса);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецПроцедуры

Процедура УстановитьБезопасноеСоединение(
    Знач ПутьКФайлуСертификатаУдостоверяющегоЦентра,
    Знач ПутьКФайлуЗакрытогоКлюча,
    Знач ПутьКФайлуСертификатаКлиента,
    Знач АдресСервера,
    Знач ИмяПользователя,
    Знач Пароль,
    Знач ПортСервера = 5672,
    Знач ВиртуальныйХост = "/",
    Знач ЧастотаПульса = 15,
    Знач ПроверкаСоответствияИмениСервера = Истина) Экспорт

    Попытка
        Клиент.ConnectSecure(ПутьКФайлуСертификатаУдостоверяющегоЦентра, 
			ПутьКФайлуЗакрытогоКлюча, 
			ПутьКФайлуСертификатаКлиента, 
			АдресСервера, ПортСервера,
			ИмяПользователя, Пароль, 
			ВиртуальныйХост, ЧастотаПульса, ПроверкаСоответствияИмениСервера);
    Исключение
        СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
    КонецПопытки;

КонецПроцедуры

// Позволяет получить внутренний объект внешней компоненты для низкоуровнего взаимодействия с RMQ
//
Функция ПолучитьОбъектВнешнейКомпоненты() Экспорт
	Возврат Клиент;
КонецФункции

// Настроить тонкие параметры соединения
//
// Параметры:
//  КоличествоКаналов			 - Число	 - Максимальное количество каналов для соединения
//  РазмерФрейма	 			 - Число	 - Размер фрейма для отравки сообщения.
//  СекундыПостояннойПроверки	 - Число	 - Количество секунд при котором сервер RMQ будет проверять соединение
Процедура НастроитьСоединение(Знач КоличествоКаналов = 0,
	Знач РазмерФрейма = 131072,
	Знач СекундыПостояннойПроверки = 8) Экспорт
	
	Попытка
		Клиент.Tune(КоличествоКаналов, РазмерФрейма, СекундыПостояннойПроверки);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

// Объявить точку обмена
//
// Параметры:
//  ИмяТочкиОбмена		 - Строка	 - Имя exchange
//  ТипТочкиОбмена		 - Строка	 - "direct", "fanout", "topic"
//  ДолжнаСуществовать	 - Булево	 - Не создавать новую, выбросить исключение, если такой точки нет.
//  Надежная			 - Булево	 - Сохранять сообщения на диске на случай рестарта RMQ (не рекомендуется)
//  АвтоУдаляемая		 - Булево	 - Удалить после того, как от точки будут отвязаны все очереди.
//
Процедура ОбъявитьТочкуОбмена(Знач ИмяТочкиОбмена,
	Знач ТипТочкиОбмена = "direct",
	Знач ДолжнаСуществовать = Ложь,
	Знач Надежная = Ложь,
	Знач АвтоУдаляемая = Ложь) Экспорт

	Попытка
		Клиент.DeclareExchange(ИмяТочкиОбмена, ТипТочкиОбмена, ДолжнаСуществовать, Надежная, АвтоУдаляемая);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецПроцедуры

// Отправить сообщение
//
// Параметры:
//  ИмяТочкиОбмена		 - Строка	 - Имя точки в которую отправляется сообщение
//  Сообщение			 - Строка	 - Тело сообщения
//  КлючМаршрутизации	 - Строка	 - ключ маршрутизации (см. руководство RMQ)
//  ВремяЖизни			 - Строка	 - Время жизни сообщения в миллисекундах
//  Персистентное		 - Булево	 - Сбрасывать сообщение на диск
//
Процедура ОтправитьСообщение(Знач ИмяТочкиОбмена, Знач Сообщение, Знач КлючМаршрутизации = "", 
							 ВремяЖизни = 0, Персистентное = Истина) Экспорт

	Попытка
		Клиент.BasicPublish(ИмяТочкиОбмена, КлючМаршрутизации, Сообщение, ВремяЖизни, Персистентное);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецПроцедуры

// Объявить очередь
//
// Параметры:
//  ИмяОчереди			 - Строка	 - имя объявляемой очереди. Если передать пустую строку, то метод вернет имя, сгенерированное сервером.
//  ДолжнаСуществовать	 - Булево	 - не создавать очередь с таким именем, использовать существующую
//  Надежная			 - Булево	 - кешировать сообщения на диске, на случай падения RMQ.
//  ЭксклюзивныйДоступ	 - Булево	 - только текущее соединение может иметь доступ к этой очереди.
//  Автоудаляемая		 - Булево	 - удалить очередь если к ней был подключен, а затем отключен читающий клиент.
//  Аргументы			 - Соответствие - параметры создания очереди (см. протокол AMQP)
// 
// Возвращаемое значение:
//   - Имя очереди, сгенерированное сервером, или заданное явно в 1-м параметре.
//
Функция ОбъявитьОчередь(Знач ИмяОчереди = "", 
	Знач ДолжнаСуществовать = Ложь,
	Знач Надежная = Ложь,
	Знач ЭксклюзивныйДоступ = Ложь,
	Знач Автоудаляемая = Ложь,
	Знач Аргументы = Неопределено) Экспорт

	Идентификатор = -1;
	Если ЗначениеЗаполнено(Аргументы) Тогда
		Таб = ПолучитьТаблицуAMQP(Аргументы);
		Идентификатор = Таб.Идентификатор;
	КонецЕсли;
	
	Попытка
		Возврат Клиент.DeclareQueue(ИмяОчереди, ДолжнаСуществовать, Надежная, ЭксклюзивныйДоступ, Автоудаляемая, Идентификатор);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецФункции

// Установить связь очереди. Создает маршрут от точки обмена до очереди.
//
// Параметры:
//  ИмяОчереди			 - Строка	 - Имя очереди
//  ИмяТочкиОбмена		 - Строка	 - Имя точки обмена
//  КлючМаршрутизации	 - Строка	 - ключ маршрутизации. 
//    Только сообщения с этим ключом будут попадать в очередь. Для точки обмена topic возможны маски * и #
//
Процедура УстановитьСвязьОчереди(Знач ИмяОчереди, Знач ИмяТочкиОбмена, Знач КлючМаршрутизации = "") Экспорт
	
	Попытка
		Клиент.BindQueue(ИмяОчереди, ИмяТочкиОбмена, КлючМаршрутизации);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

// Установить связь точек обмена между собой. Создает маршрут от одной точки обмена до другой.
//
// Параметры:
//  Источник			 - Строка	 - Имя исходной точки обмена
//  Приемник			 - Строка	 - Имя точки обмена, в которую будут направляться сообщения из источника
//  КлючМаршрутизации	 - Строка	 - ключ маршрутизации. 
//    Только сообщения с этим ключом будут попадать в точку-приемник. Для точки обмена topic возможны маски * и #
//  Аргументы			 - Соответствие - параметры создания связи (см. протокол AMQP)
//
Процедура УстановитьСвязьТочекОбмена(Знач Источник, Знач Приемник, Знач КлючМаршрутизации = "", Знач Аргументы = Неопределено) Экспорт
	
	Идентификатор = -1;
	Если ЗначениеЗаполнено(Аргументы) Тогда
		Таб = ПолучитьТаблицуAMQP(Аргументы);
		Идентификатор = Таб.Идентификатор;
	КонецЕсли;
	
	Попытка
		Клиент.BindExchange(Источник, Приемник, КлючМаршрутизации, Идентификатор);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

// Начать чтение. Регистрирует потребителя сообщений для очереди.
//
// Параметры:
//  ИмяОчереди		 - Строка	 - Очередь из которой будем читать сообщения.
//  ИмяПотребителя	 - Строка	 - имя потребителя. Если не задан, то имя потребителя сгенерирует сервер и вернет из метода
//  БезПодтверждений - Строка	 - не ждать подтверждения обработки. Сообщения будут удалены из очереди сразу после отправки на клиента.
//  Монопольно		 - Строка	 - монопольно захватить очередь 
//  РазмерВыборки	 - Строка	 - количество сообщений единовременно отправляемых клиенту. Оптимизационный параметр, если > 1 усложняет программирование клиента. 
// 
// Возвращаемое значение:
//   - Строка. Имя потребителя, сгенерированное сервером или переданное в параметре ИмяПотребителя.
//
Функция НачатьЧтение(Знач ИмяОчереди, 
	Знач ИмяПотребителя = "", 
	Знач БезПодтверждений = Истина,
	Знач Монопольно = Ложь,
 	Знач РазмерВыборки = 1) Экспорт

	Попытка
		Возврат Клиент.BasicConsume(
			ИмяОчереди, ИмяПотребителя, БезПодтверждений, Монопольно, РазмерВыборки);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецФункции

// Получить сообщение
// Считывает сообщение из очереди. Метод блокирует текущий поток выполнения, пока не будет получено сообщение или не достигнут таймаут.
//
// Параметры:
//  ИмяПотребителя	 - Строка	 - имя зарегистрированного потребителя
//  Результат		 - Строка	 - выходной параметр. Тело сообщения.
//  Таймаут			 - Число	 - таймаут ожидания сообщения в миллисекундах. -1 означает неограниченное ожидание
// 
// Возвращаемое значение:
//   - Булево. Истина, если сообщение получено, Ложь если достигнут таймаут.
//
Функция ПолучитьСообщение(Знач ИмяПотребителя, Результат, Знач Таймаут = -1) Экспорт

	// обнуление результата
	Результат = Неопределено;
	Попытка
		Возврат Клиент.BasicConsumeMessage(ИмяПотребителя, Результат, Таймаут);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецФункции

// Отсылает серверу подтверждение (ack), что сообщение обработано и его можно удалить.
// В API жестко зашит порядок обработки сообщений. Подтвердить можно только последнее прочитанное сообщение.
// Таким образом, если prefetchCount больше единицы, то отправлять ack нужно по принципу LIFO (стеком).
//
// Если сервер не получает ack, то он не будет отправлять новых сообщений,
// а в случае обрыва связи - вышлет неподтвержденные сообщения еще раз.
//
Процедура ПодтвердитьСообщение() Экспорт
	
	Попытка
		Клиент.BasicAck();
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

// Отсылает серверу подтверждение (ack), что сообщение обработано и его можно удалить.
// Метод выполняет множественное подтверждение всех сообщений до последнего полученного.
//
// ИдентификаторДоставки - это одноименное свойство внешней компоненты.
//
Процедура ПодтвердитьВсеСообщения() Экспорт
	
	Попытка
		Клиент.BasicAck(Истина);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

// Отказывается от последнего полученного сообщения.
// Работает по принципу Ack, но в обратную сторону.
//
Процедура ОтклонитьСообщение(Знач ПоставитьВОчередь = Ложь) Экспорт

	Попытка
		Клиент.BasicReject(ПоставитьВОчередь);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецПроцедуры

// Отказывается от всех неподтвержденных сообщений до последнего полученного
// Работает по принципу Ack, но в обратную сторону.
//
Процедура ОтклонитьВсеСообщения(Знач ПоставитьВОчередь = Ложь) Экспорт
	
	Попытка
		Клиент.BasicReject(ПоставитьВОчередь, Истина);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

// Удаляет очередь с сервера
//
// Параметры:
//  ИмяОчереди				 - Строка	 - Имя очереди
//  ТолькоЕслиНеИспользуется - Строка	 - удаление будет выполнено, только если очередь не используется
//  ТолькоЕслиПустая		 - Строка	 - удаление будет выполнено, только если очередь пуста
//
// Если какое-либо условие удаления не выполнено (используется/не пустая) то выдается исключение.
//
Процедура УдалитьОчередь(Знач ИмяОчереди, Знач ТолькоЕслиНеИспользуется = Ложь, Знач ТолькоЕслиПустая = Ложь) Экспорт

	Попытка
		Клиент.DeleteQueue(ИмяОчереди, ТолькоЕслиНеИспользуется, ТолькоЕслиПустая);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецПроцедуры

// Процедура - Удалить точку обмена
//
// Параметры:
//  ИмяТочкиОбмена			 - Строка	 - имя точки обмена.
//  ТолькоЕслиНеИспользуется - Строка	 - удаление будет выполнено, только если точка обмена не используется.
//
// Если условие удаления не выполнено, то выдается исключение.
//
Процедура УдалитьТочкуОбмена(Знач ИмяТочкиОбмена, Знач ТолькоЕслиНеИспользуется = Ложь) Экспорт

	Попытка
		Клиент.DeleteExchange(ИмяТочкиОбмена, ТолькоЕслиНеИспользуется);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецПроцедуры

// Удаляет потребителя и отвязывает его от очереди.
//
// Параметры:
//  ИмяПотребителя	 - Строка	 - Имя созданного ранее потребителя.
//
Процедура ЗакончитьЧтение(Знач ИмяПотребителя) Экспорт

	Попытка
		Клиент.BasicCancel(ИмяПотребителя);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецПроцедуры

// Отсоединяет очередь от точки обмена.
//
// Параметры:
//  ИмяОчереди			 - Строка	 - имя очереди
//  ИмяТочкиОбмена		 - Строка	 - имя точки обмена
//  КлючМаршрутизации	 - Строка	 - ключ маршрутизации, указанный при создании привязки в методе УстановитьСвязьОчереди
//
Процедура ОтменитьСвязьОчереди(Знач ИмяОчереди, Знач ИмяТочкиОбмена, Знач КлючМаршрутизации = "") Экспорт

	Попытка
		Клиент.UnbindQueue(ИмяОчереди, ИмяТочкиОбмена, КлючМаршрутизации);
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;

КонецПроцедуры

// Запросить у компоненты установленные свойства сообщения
//
// Параметры:
//    ТребуемыеСвойства - Структура, Неопределено - Список свойств, разделенный запятыми
//		Если Неопределено, тогда возвращаются все значения свойств и в отдельном свойстве "Заголовки" возвращаются заголовки сообщения
//
Функция ПолучитьСвойстваСообщения(Знач ТребуемыеСвойства = Неопределено) Экспорт
	
	ПолученныеСвойства = Новый Структура;
	
	Если ПустаяСтрока(ТребуемыеСвойства) Тогда
		
		Для Каждого КлючИЗначение Из СписокСвойствКлиента() Цикл
			Попытка
				
				ПолученныеСвойства.Вставить(КлючИЗначение.Ключ, Клиент[КлючИЗначение.Ключ]);
				
			Исключение
				
				СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());

			КонецПопытки;
			
		КонецЦикла;
		
		ПолученныеСвойства.Вставить("Заголовки", ПолучитьЗаголовки());

	Иначе
		
		Пока Не ПустаяСтрока(ТребуемыеСвойства) Цикл
			
			Поз = Найти(ТребуемыеСвойства, ",");
			Если Поз = 0 Тогда
				ИмяСвойства = ТребуемыеСвойства;
				ТребуемыеСвойства = "";
			Иначе
				ИмяСвойства = Лев(ТребуемыеСвойства, Поз-1);
				ТребуемыеСвойства = Сред(ТребуемыеСвойства, Поз+1);
			КонецЕсли;
			
			Если Не ПустаяСтрока(ИмяСвойства) Тогда
				Если НРег(ИмяСвойства) = "headers" ИЛИ 
						НРег(ИмяСвойства) = "заголовки" Тогда
					ПолученныеСвойства.Вставить(ИмяСвойства, ПолучитьЗаголовки());
				Иначе
					Попытка
						ИмяСвойстваБезПробелов = СокрЛП(ИмяСвойства);
						ПолученныеСвойства.Вставить(ИмяСвойстваБезПробелов, Клиент[ИмяСвойстваБезПробелов]);
					Исключение
						СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
					КонецПопытки;
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	Возврат ПолученныеСвойства;
	
КонецФункции

// Установить свойства сообщения согласно протокола AMQP
//
// Параметры:
//  СтруктураСвойств - Структура - структура со значениями свойств, которые надо установить
//                     Названия ключей соответствия доступны в методе ОчередьСообщений.ВозможныеСвойстваСообщения
//
Процедура УстановитьСвойстваСообщения(Знач СтруктураСвойств) Экспорт
	
	Для Каждого КлючИЗначение Из СтруктураСвойств Цикл
		Если НРег(КлючИЗначение.Ключ) = "headers" ИЛИ НРег(КлючИЗначение.Ключ) = "заголовки" Тогда
			УстановитьЗаголовки(КлючИЗначение.Значение);
		Иначе
			Попытка
				Клиент[КлючИЗначение.Ключ] = КлючИЗначение.Значение;
			Исключение
				СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Сброс всех ранее установленных свойств
//
Процедура СброситьЗначенияСвойств() Экспорт
	Попытка
		Клиент.ClearProperties();
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
КонецПроцедуры

// Устанавливает заголовки сообщения
//
Процедура УстановитьЗаголовки(Знач Заголовки) Экспорт
	
	Перем Таблица;
	Таблица = ПолучитьТаблицуAMQP(Заголовки);
	
	Попытка
		Клиент.Headers = Таблица.Идентификатор;
	Исключение
		СгенерироватьТочнуюОшибку(ИнформацияОбОшибке());
	КонецПопытки;
	
КонецПроцедуры

// Получает заголовки сообщения в виде соответствия
//
Функция ПолучитьЗаголовки() Экспорт
	
	Идентификатор = Клиент.Заголовки;
	Если Идентификатор < 0 Тогда
		Возврат Новый Соответствие;
	КонецЕсли;
	
	Попытка
		Таблица = Новый ("AddIn.V8RMQClient.AMQPTable");
		Таблица.Открыть(Идентификатор);
		Ключи = Таблица.ПолучитьКлючи();
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Таблица, ИнформацияОбОшибке());
	КонецПопытки;
	
	Заголовки = Новый Соответствие;
	
	Пока Не ПустаяСтрока(Ключи) Цикл
		Поз = Найти(Ключи, "|");
		Если Поз = 0 Тогда
			Ключ = Ключи;
			Ключи = "";
		Иначе
			Ключ = Лев(Ключи, Поз-1);
			Ключи = Сред(Ключи, Поз+1);
		КонецЕсли;
		
		Попытка
			Заголовки.Вставить(Ключ, Таблица.Получить(Ключ));
		Исключение
			ВызватьИсключение ТекстТочнойОшибкиОбъекта(Таблица, ИнформацияОбОшибке());
		КонецПопытки;
	КонецЦикла;
	
	Возврат Заголовки;
	
КонецФункции

// Создает таблицу AMQP на базе соответствия.
//
Функция ПолучитьТаблицуAMQP(Знач Соответствие) Экспорт
	
	Перем Таблица;
	Попытка
		Таблица = Новый ("AddIn.V8RMQClient.AMQPTable");
		Таблица.Создать();
		Для Каждого КЗ Из Соответствие Цикл
			// Обход поведения платформы с помощью временных переменных.
			// платформа пытается проверять КЗ.Ключ и КЗ.Значение на доступность записи в эти свойства
			Ключ = КЗ.Ключ;
			Значение = КЗ.Значение;
			Таблица.Вставить(Ключ, Значение);
		КонецЦикла;
		
	Исключение
		ВызватьИсключение ТекстТочнойОшибкиОбъекта(Таблица, ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Таблица;
	
КонецФункции

// Переключает компоненту в режим передачи двоичных данных
//
// Параметры:
//  ВключитьДвоичныйКанал	 - Булево - включение/выключение канала двоичных данных
//  Совместимость			 - Булево - включение совместимости для старых платформ.
//
Процедура УстановитьРежимДвоичногоКанала(Знач ВключитьДвоичныйКанал, Знач Совместимость = Неопределено) Экспорт

	Если ВключитьДвоичныйКанал и Совместимость = Неопределено Тогда
		СИ = Новый СистемнаяИнформация;
		КомпонентыВерсии = СтрРазделить(СИ.ВерсияПриложения,".");
		
		Если КомпонентыВерсии[1] <> "3" или Число(КомпонентыВерсии[2]) < 10 Тогда
			Совместимость = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Клиент.ДвоичныйКанал = ВключитьДвоичныйКанал;
	Если ВключитьДвоичныйКанал Тогда
		Клиент.СовместимостьДвоичныхДанных = Совместимость;
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ТекстТочнойОшибки(Знач ИнформацияОбОшибке)
	
	Возврат ТекстТочнойОшибкиОбъекта(Клиент, ИнформацияОбОшибке);
	
КонецФункции

Функция ТекстТочнойОшибкиОбъекта(Знач Объект, Знач ИнформацияОбОшибке)
	
	ПолныйТекст = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке) + 
				?(Объект = Неопределено,"","
				|" + Объект.GetLastError());
	
	Возврат ПолныйТекст;
	
КонецФункции

// Из-за несовершенства NativeAPI неудобно получать текст ошибок компоненты
// Метод позволяет выбросить исключение с новым текстом ошибки.
//  Недостатки: теряется стек вызовов
//
// Параметры:
//  ИнформацияОбОшибке - Тип:ИнформацияОбОшибке
//                 исходное исключение 1С
//
Процедура СгенерироватьТочнуюОшибку(Знач ИнформацияОбОшибке)

	ВызватьИсключение ТекстТочнойОшибки(ИнформацияОбОшибке);

КонецПроцедуры

Функция СписокСвойствКлиента()
	
	Возврат ОчередьСообщений.ВозможныеСвойстваСообщения();

КонецФункции

Процедура ПодключитьКомпоненту()
	// расположение можно изменить в зависимости от конкретного внедрения	
	ТипПодключенияКомпоненты = РегистрыСведений.гкс_НастройкиИнтеграционногоАдаптера.ТипПодключенияКомпоненты();	
	УспешноПодключили = ПодключитьВнешнююКомпоненту("ОбщийМакет.V8RMQClient", "V8RMQClient", 
		ТипВнешнейКомпоненты.Native, ТипПодключенияКомпоненты);
	
	Если УспешноПодключили Тогда
		Клиент = Новый("AddIn.V8RMQClient.V8RMQClient");
	Иначе		
	    ВызватьИсключение НСтр("ru = 'Не удалось подключить внешнюю компоненту V8RMQClient'");
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

ПодключитьКомпоненту();

#КонецЕсли
