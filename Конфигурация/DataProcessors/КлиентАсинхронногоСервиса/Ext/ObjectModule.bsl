#Если Сервер ИЛИ ТолстыйКлиентОбычноеПриложение Тогда

Перем Клиент;
Перем мИмяСервиса;
Перем мИмяОчереди;
Перем мИмяТочкиДоступа;

////////////////////////////////////////////////////////////
// Программный интерфейс

// Замена конструктора
//
Процедура Инициализация() Экспорт

	Если Клиент = Неопределено Тогда
		Клиент = ОчередьСообщений.ПолучитьЭкземплярКомпоненты(ЭтотОбъект.КлючСоединения);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает клиент очереди сообщений для тонкой настройки канала.
//
// Возвращаемое значение:
//   ОбработкаОбъект.КлиентОчередиСообщений
//
Функция ИспользуемыйКлиент() Экспорт

	Возврат Клиент;

КонецФункции // ИспользуемыйКлиент()

Процедура УстановитьИмяСервиса(Знач ИмяСервиса) Экспорт

	мИмяСервиса = ИмяСервиса;

КонецПроцедуры

Процедура СоздатьОчередьДляОтветов(Знач ИмяОчереди) Экспорт
	
	СоздаватьМонопольно = Истина;
	Если Не ПустаяСтрока(ИмяОчереди) Тогда
		СоздаватьМонопольно = Ложь;
	КонецЕсли;
	
	ОткрытьСоединение();
	
	мИмяОчереди = Клиент.ОбъявитьОчередь(ИмяОчереди,,,СоздаватьМонопольно);
	мИмяТочкиДоступа = "xchg-" + мИмяОчереди;
	Клиент.ОбъявитьТочкуОбмена(мИмяТочкиДоступа, "direct",,,Истина);
	Клиент.УстановитьСвязьОчереди(мИмяОчереди, мИмяТочкиДоступа);
	Клиент.НачатьЧтение(мИмяОчереди, ИмяПотребителя(), Истина);
	
КонецПроцедуры

Процедура УдалитьОчередьДляОтветов() Экспорт

	Если Не ПустаяСтрока(мИмяОчереди) Тогда
			
		Клиент.ЗакончитьЧтение(ИмяПотребителя());
		Клиент.ОтменитьСвязьОчереди(мИмяОчереди, мИмяТочкиДоступа);
		Клиент.УдалитьТочкуОбмена(мИмяТочкиДоступа, Истина);
		Клиент.УдалитьОчередь(мИмяОчереди, Истина);
		
	КонецЕсли;
	
КонецПроцедуры


// Вызывает метод удаленного сервиса
//
Функция Вызвать(Знач ИмяМетода, Знач Параметры, Знач КлючМаршрутизации = "") Экспорт

	ОткрытьСоединение();
	СоздатьОчередьПриемкиОтветов();
	
	Если ВерсияПротоколаRPC = 1 Тогда
		Возврат ОтправитьВызовВерсия1(ИмяМетода, КлючМаршрутизации, Параметры);
	ИначеЕсли ВерсияПротоколаRPC = 2 Тогда
		Возврат ОтправитьВызовВерсия2(ИмяМетода, КлючМаршрутизации, Параметры);
	Иначе
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Неизвестная версия протокола RPC: %1'"), ВерсияПротоколаRPC);
	КонецЕсли;

КонецФункции

Функция ОтправитьВызовВерсия1(Знач ИмяМетода, КлючМаршрутизации, Знач Параметры)
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("id", Строка(Новый УникальныйИдентификатор));
	СтруктураЗапроса.Вставить("reply_to", мИмяТочкиДоступа);
	СтруктураЗапроса.Вставить("method", ИмяМетода);
	СтруктураЗапроса.Вставить("params", Параметры);
	
	ТелоЗапроса = Обработки.АсинхронныйСервис.ЗаписатьСообщениеОбмена(СтруктураЗапроса);
	
	Клиент.ОтправитьСообщение(Обработки.АсинхронныйСервис.ИмяТочкиОбмена(мИмяСервиса), ТелоЗапроса, КлючМаршрутизации);
	
	Возврат СтруктураЗапроса.id;

КонецФункции // ОтправитьВызовВерсия1()

Функция ОтправитьВызовВерсия2(Знач ИмяМетода, КлючМаршрутизации, Знач Параметры)
	
	СтруктураЗапроса = Новый Структура;
	СтруктураЗапроса.Вставить("method", ИмяМетода);
	СтруктураЗапроса.Вставить("params", Параметры);
	
	ТелоЗапроса = Обработки.АсинхронныйСервис.ЗаписатьСообщениеОбмена(СтруктураЗапроса);
	
	Свойства = Новый Структура("CorrelationId,ReplyTo",Строка(Новый УникальныйИдентификатор),мИмяТочкиДоступа);
	Клиент.УстановитьСвойстваСообщения(Свойства);
	Клиент.ОтправитьСообщение(Обработки.АсинхронныйСервис.ИмяТочкиОбмена(мИмяСервиса), ТелоЗапроса, КлючМаршрутизации);
	
	Возврат Свойства.CorrelationId;

КонецФункции // ОтправитьВызовВерсия2()

// Синхронно ждет ответа нужное количество времени.
// Возвращает данные ответа в виде структуры, или Неопределено, если истек таймаут.
// Таймаут задается в миллисекундах.
//
Функция ОжидатьОтвет(Знач Таймаут = -1) Экспорт

	Данные = Неопределено;
	СообщениеПолучено = Клиент.ПолучитьСообщение(ИмяПотребителя(), Данные, Таймаут);
	
	Если СообщениеПолучено Тогда
		Возврат СериализоватьОтвет(Данные);
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ОжидатьОтвет()

// если в ответе пришла ерунда, то это нарушение протокола
// мы не знаем, как это обработать, поэтому просто выбросим исключение сериализации
//
Функция СериализоватьОтвет(Знач Ответ)

	Попытка
		Данные = Обработки.АсинхронныйСервис.ПрочитатьСообщениеОбмена(Ответ);
	Исключение
		ТекстОшибки = СтрШаблон(НСтр("ru = 'Некорректный формат ответа
                                     |%1
									 |%2'"),
						Ответ,
						ОписаниеОшибки());
		
		ЗаписьЖурналаРегистрации("АсинхронныйСервис.НеверныйФормат", 
				УровеньЖурналаРегистрации.Ошибка,,,
				ТекстОшибки);
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Данные;

КонецФункции // СериализоватьОтвет()

////////////////////////////////////////////////////////////
// Служебные методы

Процедура ОткрытьСоединение()
	
	Если Клиент <> Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Инициализация();
	// Выбросит исключение, если сервис не зарегистрирован в RMQ
	Клиент.ОбъявитьТочкуОбмена(Обработки.АсинхронныйСервис.ИмяТочкиОбмена(мИмяСервиса),"direct", Истина);
	
КонецПроцедуры

Процедура СоздатьОчередьПриемкиОтветов()

	Если ЗначениеЗаполнено(мИмяОчереди) Тогда
		Возврат;
	КонецЕсли;
	
	СоздатьОчередьДляОтветов("");
	
КонецПроцедуры

Функция ИмяПотребителя()

	Возврат мИмяОчереди + ".cons";

КонецФункции // ИмяПотребителя()
///////////////////////////////////////////////////////

ВерсияПротоколаRPC = АсинхронныеСервисыПереопределяемый.ВерсияПротоколаRPCПоУмолчанию();

#КонецЕсли