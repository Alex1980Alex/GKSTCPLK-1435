#Область СлужебныйПрограммныйИнтерфейс

// Добавляет простой обработчик события без привязки к очереди.
// Метод заменяет собой старый API добавления обработчиков с привязкой к имени очереди.
//
// Параметры:
//   Обработчики - Коллекция обработчиков, возвращаемая методом НоваяКоллекцияРегистрацииОбработчиков
//   ИмяПроцедуры - Строка - Имя метода-обработчика из общего модуля, в формате "ОбщийМодуль.ИмяПроцедуры"
//   ВерсияПротокола - Число/Неопределено - версия протокола
//
Процедура ДобавитьОбработчикСообщения(Знач Обработчики, Знач ИмяПроцедуры, Знач ВерсияПротокола = Неопределено) Экспорт
	Если Не ЗначениеЗаполнено(ВерсияПротокола) Тогда
		ВерсияПротокола = ПолучениеСообщенийПереопределяемый.ВерсияПротоколаПоУмолчанию();
	КонецЕсли;
	
	ПроверитьПоддержкуВерсииПротокола(ВерсияПротокола);

	ОписаниеОбработчика = Обработчики.Добавить();
	ОписаниеОбработчика.МетодОбработчик = ИмяПроцедуры;
	ОписаниеОбработчика.ВерсияПротокола = ВерсияПротокола;
	
КонецПроцедуры

// УСТАРЕЛ. Добавляет обработчик события очереди (см. метод ДобавитьОбработчикСообщения)
//
//
// Параметры:
//   Обработчики - Коллекция обработчиков, возвращаемая методом НоваяКоллекцияРегистрацииОбработчиков
//   ИмяОчереди - Строка - Имя очереди (ИГНОРИРУЕТСЯ)
//   ИмяПроцедуры - Строка - Имя метода-обработчика из общего модуля, в формате "ОбщийМодуль.ИмяПроцедуры"
//   ВерсияПротокола - Число/Неопределено - версия протокола
//
Процедура ДобавитьОбработчикСобытия(Знач Обработчики, Знач ИмяОчереди, Знач ИмяПроцедуры, Знач ВерсияПротокола = Неопределено) Экспорт
	Если Обработчики.Колонки.Найти("ИмяОчереди") = Неопределено Тогда
		Обработчики.Колонки.Добавить("ИмяОчереди");
	КонецЕсли;
	
	ДобавитьОбработчикСообщения(Обработчики, ИмяПроцедуры, ВерсияПротокола);
	
	Обработчик = Обработчики[Обработчики.Количество()-1];
	Обработчик.ИмяОчереди = ИмяОчереди;
	
КонецПроцедуры

// Создает таблицу обработчиков событий очередей
//
//  Возвращаемое значение:
//   Соответствие - Пустая коллекция обработчиков событий
//
Функция НоваяКоллекцияРегистрацииОбработчиков() Экспорт
	
	КоллекцияРегистрацииОбработчиков = Новый ТаблицаЗначений;
	КоллекцияРегистрацииОбработчиков.Колонки.Добавить("МетодОбработчик");
	КоллекцияРегистрацииОбработчиков.Колонки.Добавить("ВерсияПротокола");
	
	Возврат КоллекцияРегистрацииОбработчиков;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция НастроитьКаналДанныхПолучателя(Знач Получатель, Знач Подписка)
	
	Если Подписка = Неопределено Тогда
		Возврат Перечисления.ТипКаналаСвязиRMQ.Строка;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПодпискиНаОчередиСообщений.ТипДанныхВОчереди
	|ИЗ
	|	Справочник.ПодпискиНаОчередиСообщений КАК ПодпискиНаОчередиСообщений
	|ГДЕ
	|	ПодпискиНаОчередиСообщений.Ссылка = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", Подписка);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Не Выборка.Следующий() Тогда
		ЗаписьЖурналаРегистрации("ПолучениеСообщений.Ошибка", УровеньЖурналаРегистрации.Ошибка, , ,
			НСтр("ru = 'Регламентное задание привязано к ссылке, которая отсутствует в справочнике.'"));
		Возврат Перечисления.ТипКаналаСвязиRMQ.Строка;
	КонецЕсли;
	
	КаналСвязи = Выборка.ТипДанныхВОчереди;
	
	Если КаналСвязи <> Перечисления.ТипКаналаСвязиRMQ.Строка Тогда
		Клиент = Получатель.ИспользуемыйКлиент();
		Клиент.УстановитьРежимДвоичногоКанала(Истина);
	КонецЕсли;
	
	Возврат КаналСвязи;
	
КонецФункции

Функция ПолучитьОбработчикиСообщений(Знач ИмяОчереди, Знач КлючСоединения)
	
	Коллекция = ОчередьСообщенийПовтИсп.ПолучитьОбработчикиСообщений();	
	Фильтр = Новый Структура;
	Фильтр.Вставить("ИмяОчереди", ИмяОчереди);
	Если ЗначениеЗаполнено(КлючСоединения) Тогда
		Фильтр.Вставить("КлючСоединения", КлючСоединения);
	Иначе
		Фильтр.Вставить("КлючСоединения", Справочники.СерверыОчередейRMQ.КлючСоединенияОсновной());
	КонецЕсли;
	
	Возврат Коллекция.Скопировать(Фильтр);
	
КонецФункции

Процедура ОбработатьСообщение(Знач Данные, Знач Обработчик, Знач СвойстваСообщений, Знач ПодпискаНаОчередь, Отказ, ВернутьВОчередь)
	
	МетодОбработчик = Обработчик.МетодОбработчик;
	ВерсияПротокола = Обработчик.ВерсияПротокола;
	
	ПараметрыОбработчика = Новый Структура;
	ПараметрыОбработчика.Вставить("Данные", Данные);
	ПараметрыОбработчика.Вставить("МетодОбработчик", МетодОбработчик);
	ПараметрыОбработчика.Вставить("СвойстваСообщений", СвойстваСообщений);
	ПараметрыОбработчика.Вставить("ПодпискаНаОчередь", ПодпискаНаОчередь);
		
	Если ВерсияПротокола = 1 Тогда
		
		УстановитьБезопасныйРежим(Истина);
		Выполнить(МетодОбработчик + "(Данные, Отказ)");
		
	ИначеЕсли ВерсияПротокола = 2 Тогда
		ОбработатьСообщениеВерсияПротокола2(ПараметрыОбработчика, Отказ, ВернутьВОчередь);
	Иначе
		ПроверитьПоддержкуВерсииПротокола(ВерсияПротокола);
	КонецЕсли;
		
КонецПроцедуры

Функция ВерсияПоддерживается(Знач ВерсияПротокола)

	Если ВерсияПротокола = 1 ИЛИ ВерсияПротокола = 2 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

Процедура ПроверитьПоддержкуВерсииПротокола(Знач ВерсияПротокола)
	
	Если НЕ ВерсияПоддерживается(ВерсияПротокола) Тогда
		ВызватьИсключение СтрШаблон("Версия протокола %1 для обработчика сообщений не поддерживается", ВерсияПротокола);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьСообщениеВерсияПротокола2(ПараметрыОбработчика, Отказ, ВернутьВОчередь)
	
	Перем Данные;
	Перем МетодОбработчик;
	Перем СвойстваСообщений;
	Перем ПодпискаНаОчередь;
	
	СообщениеОбработано = Ложь; // Признак необходимости дальнейшей обработки.
	гкс_ОчередьСообщенийRMQПереопределяемый.ПриОбработкеСообщенияВерсияПротокола2(ПараметрыОбработчика,
																				  Отказ,
																				  ВернутьВОчередь,
																				  СообщениеОбработано);
	// Если сообщение обработано в переопределяемом модуле собственным обработчиком или явно установлен признак
	// отказа от дальнейшей обработки - обработка заканчивается.
	Если СообщениеОбработано ИЛИ Отказ Тогда
		Возврат;
	КонецЕсли;
	
	ПараметрыОбработчика.Свойство("Данные", Данные);
	ПараметрыОбработчика.Свойство("МетодОбработчик", МетодОбработчик);
	ПараметрыОбработчика.Свойство("СвойстваСообщений", СвойстваСообщений);
	ПараметрыОбработчика.Свойство("ПодпискаНаОчередь", ПодпискаНаОчередь);
	
	МетодОбработчикМассив = гкс_СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(МетодОбработчик, ".");	
	КоличествоСлов = МетодОбработчикМассив.Количество();
	
	Если гкс_ОчередьСообщенийRMQСлужебный.ЭтоОбработчикСоСтандартнымИменемМетода(МетодОбработчикМассив,
	                                                                             "ОбработатьСообщение") Тогда
		
		ИмяМодуля = "";
		Если КоличествоСлов = 2 Тогда
			ИмяМодуля = МетодОбработчикМассив[0];			 
		ИначеЕсли КоличествоСлов = 3 Тогда
			ИмяМодуля = МетодОбработчикМассив[0] + "." +  МетодОбработчикМассив[1];
		КонецЕсли;
		
		// В подсистеме по умолчанию определен сценарий обработки сообщений. Он должен иметь возможность выполняться
		// в небезопасном режиме исполнения
		Модуль = гкс_ОбщегоНазначения.ОбщийМодуль(ИмяМодуля);
		Модуль.ОбработатьСообщение(Данные, СвойстваСообщений, ПодпискаНаОчередь, Отказ, ВернутьВОчередь);
		
	Иначе
		
		УстановитьБезопасныйРежим(Истина);
		Выполнить(МетодОбработчик + "(Данные, СвойстваСообщений, ПодпискаНаОчередь, Отказ, ВернутьВОчередь)");	

	КонецЕсли;
	
КонецПроцедуры

// Обработка всех имеющихся сообщений из очереди
//
// Параметры:
//   ИмяОчереди - Строка - Имя очереди
//   ИнтервалОжидания - Число - интервал ожидания в секундах
//   КлючСоединения - Строка - ключ соединения, например, псевдоним/код подключенного сервера из Справочника СерверыОчередейRMQ
//		(необязательно) Значение по умолчанию - пустая строка
//   ПодпискаНаОчередь - СправочникСсылка.ПодпискиНаОчередиСообщений - ссылка на подписку на очередь
//		(необязательно) Значение по умолчанию - Неопределено
//
Процедура ПолучитьСообщениеВнутренний(
	Знач ИмяОчереди, 
	Знач ИнтервалОжидания, 
	Знач КлючСоединения = "", 
	Знач ПодпискаНаОчередь = Неопределено, 
	Знач ЧастотаПульса = Неопределено) Экспорт
	
	Перем Распаковщик;	
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если НЕ гкс_ОчередьСообщенийRMQВызовСервера.ВключенОбменСRMQ() Тогда
		Возврат;		
	КонецЕсли;
	
	гкс_КонтекстСервер.Контекст(); // При необходимости инициализирует контекст
	
	ОбработчикиСообщений = ПолучитьОбработчикиСообщений(ИмяОчереди, КлючСоединения);
	Если ОбработчикиСообщений.Количество() = 0 Тогда
		ЗаписатьОшибку(
		       СтрШаблон(НСтр("ru = 'В системе не зарегистрировано обработчиков сообщений для очереди %1'"),
		                 ИмяОчереди));
		Возврат;
	КонецЕсли;
	
	ОчередьСообщений.ОпределитьПульс(ЧастотаПульса, ИнтервалОжидания);
	
	Получатель = ОчередьСообщений.НовыйПодписчик(ИмяОчереди, КлючСоединения, ЧастотаПульса);
	ТипКанала  = НастроитьКаналДанныхПолучателя(Получатель, ПодпискаНаОчередь);
	
	Если ТипКанала = Перечисления.ТипКаналаСвязиRMQ.СтрокаGZIP Тогда
		Распаковщик = Новый("AddIn.V8RMQClient.GZipCompressor");
	КонецЕсли;
	
	ПорцияСообщений = 0;

	Данные = Неопределено;
	Пока Получатель.ПолучитьСообщение(Данные, ИнтервалОжидания*1000) Цикл
		Попытка
			СвойстваСообщений = Получатель.ПолучитьСвойстваСообщения();		
			ЗаписатьИнформацию(СтрШаблон(НСтр("ru = 'Получено сообщение из очереди %1'"), ИмяОчереди));
	
			Отказ = Ложь;
			ВернутьВОчередь = Ложь;
			
			Данные = РаспаковатьДанныеПриНеобходимости(Данные, ТипКанала, Распаковщик);
			Для Каждого Обработчик Из ОбработчикиСообщений Цикл
				ОбработатьСообщение(Данные, Обработчик, СвойстваСообщений, ПодпискаНаОчередь, Отказ, ВернутьВОчередь);
			КонецЦикла;
			
			УтсановитьПризнакОбработкиСообщения(Отказ, ВернутьВОчередь, Получатель);
						
			ПорцияСообщений = ПорцияСообщений + 1;
			Если ЗапуститьОбработкуСообщенийОчередиПриНеобходимости(ПорцияСообщений) Тогда
				ПорцияСообщений = 0;
			КонецЕсли;
			
		Исключение
			
			ТекстОшибки = СтрШаблон(НСтр("ru = 'Ошибка обработки сообщения очереди %1.'"), ИмяОчереди) + "
			|" + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
			ЗаписатьОшибку(ТекстОшибки);
			
			// Сообщение не может быть обработано и будет оставлено в очереди
			// до тех пор, пока "затор" не будет устранен.
			ВызватьИсключение;
			
		КонецПопытки;
	КонецЦикла;
	
	ЗапуститьОбработкуСообщенийОчередиПриНеобходимости(ПорцияСообщений, Истина);
	ЗаписатьИнформацию(СтрШаблон(НСтр("ru = 'Получены все сообщения из очереди %1'"), ИмяОчереди));
	
	гкс_КонтекстСервер.УдалитьКонтекст();
	
КонецПроцедуры

#Область ОбработчикиРегламентныхЗаданий

Процедура ПолучитьСообщение(
	Знач ИмяОчереди, 
	Знач ИнтервалОжидания, 
	Знач КлючСоединения = "", 
	Знач ПодпискаНаОчередь = Неопределено, 
	Знач ЧастотаПульса = Неопределено) Экспорт 
	
	гкс_ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания("ПолучениеСообщенийИзОчередей");
	ПолучитьСообщениеВнутренний(ИмяОчереди, ИнтервалОжидания, КлючСоединения, ПодпискаНаОчередь, ЧастотаПульса);
	
КонецПроцедуры

#КонецОбласти

#Область ПолучениеСообщений

Процедура УтсановитьПризнакОбработкиСообщения(Знач Отказ, Знач ВернутьВОчередь, Получатель) 
	
	Если Не Отказ Тогда
		Получатель.СообщениеОбработано();
	Иначе
		Получатель.ОтклонитьСообщение(ВернутьВОчередь);
	КонецЕсли;

КонецПроцедуры

Функция РаспаковатьДанныеПриНеобходимости(Данные, ТипКанала, Распаковщик)
	
	Если ТипКанала = Перечисления.ТипКаналаСвязиRMQ.СтрокаGZIP Тогда
		Данные = Распаковщик.РаспаковатьСтроку(Данные);
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

Функция ЗапуститьОбработкуСообщенийОчередиПриНеобходимости(Знач ПорцияСообщений, 
                                                           Знач ОтключитьКонтрольРазмераПорции = Ложь) Экспорт
	
	КонтрольРазмераПорции = Ложь;
	Если НЕ ОтключитьКонтрольРазмераПорции Тогда
		КонтрольРазмераПорции = ПорцияСообщений > 0;
	КонецЕсли;
	
	МаксимальноеКоличествоПотоков = Обработки.гкс_ОбработчикСообщенийRMQ.КоличествоПотоковВыполнения();
	ЭтоФайловаяБаза = гкс_ОбщегоНазначенияКлиентСервер.ИнформационнаяБазаФайловая();
	
	Если НЕ ЭтоФайловаяБаза 
	     И (НЕ КонтрольРазмераПорции ИЛИ(КонтрольРазмераПорции И ПорцияСообщений > МаксимальноеКоличествоПотоков)) Тогда
			
		ОбработанныеПотоки = ПолученныеПотокиСобытийИзКонтекста();
		Для Каждого ОбработанныйПоток Из ОбработанныеПотоки Цикл 	
			гкс_ОчередьСообщенийRMQВызовСервера.ЗапуститьОбработкуСообщенийОчереди(Неопределено, ОбработанныйПоток);
		КонецЦикла;
		
		гкс_КонтекстСервер.УдалитьЗначениеКонтекстаПолученныхПотоков();
		
		Возврат Истина;
				
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

Функция ПолученныеПотокиСобытийИзКонтекста() 
	
	ПолученныеПотокиКонтекст = гкс_КонтекстСервер.ПолученныеПотокиИзКонтекста();
	ПолученныеПотоки = Новый Массив;
	
	Если НЕ ТипЗнч(ПолученныеПотокиКонтекст) = Тип("Соответствие") Тогда
		Возврат ПолученныеПотоки;
	КонецЕсли;
	
	Для Каждого ПотокИзКонтекста Из ПолученныеПотокиКонтекст Цикл
		ПолученныеПотоки.Добавить(ПотокИзКонтекста.Ключ);
	КонецЦикла;
	
	Возврат ПолученныеПотоки;
	
КонецФункции

Процедура ЗаписатьОшибку(ТекстОшибки)
	
	ЗаписьЖурналаРегистрации("ПолучениеСообщений", 
	                         УровеньЖурналаРегистрации.Ошибка,
	                         Неопределено,
	                         Неопределено,
							 ТекстОшибки);
	
КонецПроцедуры

Процедура ЗаписатьИнформацию(СтрокаИнформации)
	
	ЗаписьЖурналаРегистрации("ПолучениеСообщений", 
	                         УровеньЖурналаРегистрации.Информация,
	                         Неопределено,
	                         Неопределено,
							 СтрокаИнформации);

КонецПроцедуры

#КонецОбласти

#КонецОбласти

